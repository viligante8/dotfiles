#!/bin/bash

# Universal project picker for tmux
# Reads project directories from dotfiles.config.json and shows existing sessions at the top

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONFIG_TOOL="$SCRIPT_DIR/dotfiles-config"

sanitize_session_name() {
    echo "$1" | sed 's/[^a-zA-Z0-9]/-/g'
}

# Check config helper
if [ ! -x "$CONFIG_TOOL" ]; then
    echo "Error: Config helper not found or not executable at $CONFIG_TOOL"
    exit 1
fi

# Create temporary files for the menu
TEMP_FILE=$(mktemp)
EXISTING_SESSIONS_FILE=$(mktemp)
ALL_PROJECTS_FILE=$(mktemp)
SEEN_PATHS_FILE=$(mktemp)

# Get list of existing tmux sessions
existing_sessions=$(tmux list-sessions -F "#{session_name}" 2>/dev/null || true)

# Collect all project directories from config
all_projects=()

project_roots=()
while IFS= read -r root || [ -n "$root" ]; do
    [ -z "$root" ] && continue
    project_roots+=("$root")
done < <("$CONFIG_TOOL" project-roots)

if [ ${#project_roots[@]} -eq 0 ]; then
    echo "Error: no project roots configured in dotfiles.config.json"
    exit 1
fi

for expanded_dir in "${project_roots[@]}"; do
    if [ -d "$expanded_dir" ]; then
        # Scan subdirectories
        for dir in "$expanded_dir"/*; do
            if [ -d "$dir" ]; then
                basename_dir=$(basename "$dir")
                real_path=$(realpath "$dir" 2>/dev/null || echo "$dir")
                
                # Check if we've seen this path before
                if ! grep -Fxq "$real_path" "$SEEN_PATHS_FILE"; then
                    echo "$real_path" >> "$SEEN_PATHS_FILE"
                    all_projects+=("$basename_dir -> $dir")
                fi
            fi
        done
    fi
done

# Separate existing sessions from new projects
for project in "${all_projects[@]}"; do
    project_name=$(echo "$project" | cut -d' ' -f1)
    # Convert project name to session name format (replace special chars with dashes)
    session_name=$(sanitize_session_name "$project_name")
    
    # Check if this project has an existing session
    if echo "$existing_sessions" | grep -q "^${session_name}$"; then
        echo "ðŸ”„ $project" >> "$EXISTING_SESSIONS_FILE"
    else
        echo "$project" >> "$ALL_PROJECTS_FILE"
    fi
done

# Combine files: existing sessions first, then all other projects
cat "$EXISTING_SESSIONS_FILE" "$ALL_PROJECTS_FILE" > "$TEMP_FILE"

# Use fzf to show the picker
selected=$(cat "$TEMP_FILE" | fzf --height=40% --layout=reverse --border --prompt="Select project: ")

# Clean up temp files
rm "$TEMP_FILE" "$EXISTING_SESSIONS_FILE" "$ALL_PROJECTS_FILE" "$SEEN_PATHS_FILE"

# Exit if nothing selected
if [ -z "$selected" ]; then
    exit 0
fi

# Extract project name and path (remove emoji prefix if present)
project_name=$(echo "$selected" | sed 's/^ðŸ”„ //' | cut -d' ' -f1)
project_path=$(echo "$selected" | sed 's/^ðŸ”„ //' | cut -d'>' -f2 | xargs)

# If this is a git repo with multiple worktrees, ask which one to use
worktree_paths=()
repo_name="${project_name%.git}"
current_worktree_path=""
current_is_bare=0

while IFS= read -r line || [ -n "$line" ]; do
    case "$line" in
        worktree\ *)
            current_worktree_path="${line#worktree }"
            current_is_bare=0
            ;;
        bare)
            current_is_bare=1
            ;;
        "")
            if [ -n "$current_worktree_path" ] && [ "$current_is_bare" -eq 0 ] && [ -d "$current_worktree_path" ]; then
                worktree_paths+=("$current_worktree_path")
            fi
            current_worktree_path=""
            current_is_bare=0
            ;;
    esac
done < <(git -C "$project_path" worktree list --porcelain 2>/dev/null || true)

if [ -n "$current_worktree_path" ] && [ "$current_is_bare" -eq 0 ] && [ -d "$current_worktree_path" ]; then
    worktree_paths+=("$current_worktree_path")
fi

if [ ${#worktree_paths[@]} -gt 1 ]; then
    WORKTREE_TEMP_FILE=$(mktemp)
    WORKTREE_EXISTING_SESSIONS_FILE=$(mktemp)
    WORKTREE_ALL_FILE=$(mktemp)

    for worktree_path in "${worktree_paths[@]}"; do
        worktree_name=$(basename "$worktree_path")

        if [ "$worktree_name" = "$repo_name" ]; then
            worktree_session_base="$repo_name"
        else
            worktree_session_base="${repo_name}-${worktree_name}"
        fi
        worktree_session_name=$(sanitize_session_name "$worktree_session_base")

        worktree_entry="$worktree_name -> $worktree_path"

        if echo "$existing_sessions" | grep -Fxq "$worktree_session_name"; then
            echo "ðŸ”„ $worktree_entry" >> "$WORKTREE_EXISTING_SESSIONS_FILE"
        else
            echo "$worktree_entry" >> "$WORKTREE_ALL_FILE"
        fi
    done

    cat "$WORKTREE_EXISTING_SESSIONS_FILE" "$WORKTREE_ALL_FILE" > "$WORKTREE_TEMP_FILE"
    selected_worktree=$(cat "$WORKTREE_TEMP_FILE" | fzf --height=40% --layout=reverse --border --prompt="Select worktree: ")

    rm "$WORKTREE_TEMP_FILE" "$WORKTREE_EXISTING_SESSIONS_FILE" "$WORKTREE_ALL_FILE"

    if [ -z "$selected_worktree" ]; then
        exit 0
    fi

    selected_worktree_name=$(echo "$selected_worktree" | sed 's/^ðŸ”„ //' | cut -d' ' -f1)

    if [ "$selected_worktree_name" = "$repo_name" ]; then
        project_name="$repo_name"
    else
        project_name="${repo_name}-${selected_worktree_name}"
    fi
    project_path=$(echo "$selected_worktree" | sed 's/^ðŸ”„ //' | cut -d'>' -f2 | xargs)
fi

# Create session name (replace dots and special chars with dashes)
session_name=$(sanitize_session_name "$project_name")

# Use the existing tmux-workflows.sh script to create the session
exec "$SCRIPT_DIR/../tmux-workflows.sh" "$session_name" "$project_path"
